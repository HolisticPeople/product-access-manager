# Crisis Resolved: Product Slider Filter Memory Exhaustion

**Date:** October 10, 2025  
**Versions:** 2.5.7 → 2.5.8 → 2.5.9  
**Status:** Site STABLE, slider filtering DISABLED

---

## What Happened

### Timeline

1. **v2.5.7** - Implemented universal `wc_get_products()` filter to catch Product Slider Pro and all other plugins using `wc_get_products()`
2. **Deployment** - Site immediately crashed with memory exhaustion
3. **v2.5.8** - Added locking mechanism to prevent concurrent cache rebuilds
4. **Still crashing** - Even with locking, single cache rebuild was too memory-intensive
5. **v2.5.9** - Disabled `wc_get_products()` filter entirely to restore site stability

### Root Cause

The `wc_get_products()` filter caused **hundreds of simultaneous calls** to `pam_get_blocked_products_cached()` when the homepage loaded with product sliders. Each call attempted to:

1. Check cache (empty on first load)
2. Trigger `pam_calculate_blocked_products()`
3. Call `pam_get_restricted_product_ids()` which queries ALL products
4. Loop through products calling ACF's `get_field()` hundreds of times

**Memory exhaustion:** 536MB limit hit, PHP fatal errors, site crash.

### Why Locking Didn't Work

Even with the locking mechanism in v2.5.8:
- Only ONE process could rebuild the cache at a time ✓
- But that ONE process still exhausted memory ✗
- `pam_calculate_blocked_products()` is too expensive to run during page load

---

## Current State (v2.5.9)

### What Works ✓

- Shop page filtering (using `pre_get_posts`)
- Search filtering (using `pre_get_posts`)  
- FiboSearch filtering (client-side JavaScript)
- Product visibility controls
- Purchase restrictions
- Single product protection
- **Site is stable** - no crashes

### What Doesn't Work ✗

- **Product Slider Pro** - Shows restricted products to unauthorized users
- Any other widget/plugin using `wc_get_products()` directly
- Related Products (may show restricted items)
- Upsells/Cross-sells (may show restricted items)

### Why It Doesn't Work

The `wc_get_products()` filter is **commented out** (line 79 in product-access-manager.php):

```php
// TEMPORARILY DISABLED: Causes memory exhaustion when cache needs rebuild during page load
// add_filter( 'woocommerce_product_data_store_cpt_get_products_query', 'pam_filter_wc_get_products', 10, 2 );
```

---

## The Real Problem

**Cache rebuild is too expensive for on-demand execution.**

`pam_calculate_blocked_products()` must:
1. Query all products in database
2. Check ACF field for each product
3. Determine user access for each restricted product
4. Build array of blocked IDs

This takes **too much memory** and **too much time** when executed during a page request.

---

## Solutions (Choose One)

### Option A: Pre-Build Cache (Recommended)

**Strategy:** Build cache BEFORE page requests, not during them.

**Implementation:**
1. Add WP-Cron job that runs every 30 minutes
2. Pre-builds cache for guest users: `pam_get_blocked_products_cached(0)`
3. Clears and rebuilds cache for all logged-in users (or on login)
4. `wc_get_products()` filter can then safely read pre-built cache

**Pros:**
- Zero page load impact
- Filter can be re-enabled safely
- All sliders/widgets work correctly

**Cons:**
- Requires WP-Cron setup
- Cache might be slightly stale (max 30 min old)
- Need to handle logged-in users differently

### Option B: Optimize Cache Rebuild

**Strategy:** Make `pam_calculate_blocked_products()` much faster.

**Ideas:**
1. Cache the full product list separately (don't re-query every time)
2. Use direct SQL instead of `get_posts()` + `get_field()` loops
3. Pre-index restricted products in custom table
4. Reduce memory usage with chunked processing

**Pros:**
- Can keep on-demand caching
- Potentially faster across the board

**Cons:**
- Complex implementation
- May still hit memory limits with large catalogs
- Hard to guarantee performance

### Option C: Plugin-Specific Filters (Not Recommended)

**Strategy:** Hook into individual plugins instead of universal filter.

**Example:** Use `sp_wpspro_product_ids` for Product Slider Pro specifically.

**Pros:**
- Can limit scope of filter execution

**Cons:**
- Must discover and hook every plugin individually
- Doesn't solve the fundamental cache rebuild problem
- Not future-proof
- High maintenance burden

### Option D: Accept Limited Filtering (Current State)

**Strategy:** Keep sliders unfiltered, rely on shop/search/FiboSearch filtering.

**Rationale:**
- Most users find products via shop/search
- Sliders are discovery tools, not primary navigation
- Restricted products still can't be purchased without access

**Pros:**
- Zero development required
- Site is stable
- Core filtering works

**Cons:**
- Restricted products visible in sliders
- Users might click and see "No access" message
- Not ideal UX

---

## Recommendation

**Implement Option A: Pre-Built Cache via WP-Cron**

1. Add cron job to rebuild guest cache every 30 minutes
2. Clear user-specific cache on login (already implemented)
3. Re-enable `wc_get_products()` filter once cache is guaranteed to exist
4. Monitor memory usage during first cron execution

**Implementation Plan:**

```php
// Add to product-access-manager.php

// Register cron schedule
add_action( 'init', function() {
    if ( ! wp_next_scheduled( 'pam_rebuild_guest_cache' ) ) {
        wp_schedule_event( time(), 'every_30_minutes', 'pam_rebuild_guest_cache' );
    }
});

// Add custom schedule interval
add_filter( 'cron_schedules', function( $schedules ) {
    $schedules['every_30_minutes'] = array(
        'interval' => 30 * MINUTE_IN_SECONDS,
        'display'  => __( 'Every 30 Minutes' )
    );
    return $schedules;
});

// Rebuild guest cache
add_action( 'pam_rebuild_guest_cache', function() {
    pam_log( 'CRON: Rebuilding guest cache...' );
    
    // Clear old cache
    delete_transient( 'pam_hidden_products_guest' );
    
    // Rebuild
    $blocked = pam_get_blocked_products_cached( 0 );
    
    pam_log( 'CRON: Guest cache rebuilt - ' . count( $blocked ) . ' products blocked' );
});
```

Then re-enable line 79:
```php
add_filter( 'woocommerce_product_data_store_cpt_get_products_query', 'pam_filter_wc_get_products', 10, 2 );
```

---

## Files Modified

- `product-access-manager.php` (v2.5.7 → v2.5.8 → v2.5.9)
  - Added locking mechanism (v2.5.8)
  - Disabled `wc_get_products()` filter (v2.5.9)

## Git Commits

- `5704e77` - v2.5.7: Universal wc_get_products() filter
- `1fd5a35` - v2.5.8: CRITICAL FIX - Add locking mechanism
- `fa0d17f` - v2.5.9: HOTFIX - Disable wc_get_products filter

---

## Next Steps

1. **Immediate:** Confirm site is stable and shop/search filtering works
2. **Short-term:** Decide on solution (A, B, C, or D)
3. **If Option A:** Implement WP-Cron pre-building
4. **Testing:** Monitor memory usage and cache behavior
5. **Production:** Deploy with confidence once tested on staging

